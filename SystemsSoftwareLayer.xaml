<Window x:Class="EmbeddedSystemsArchitecture.SystemsSoftwareLayer"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:EmbeddedSystemsArchitecture"
        mc:Ignorable="d"
        Title="SystemsSoftwareLayer" Height="970.854" Width="1589" MaxWidth="1590" MaxHeight="970" ScrollViewer.HorizontalScrollBarVisibility="Visible">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="201*"/>
            <RowDefinition Height="544*"/>
        </Grid.RowDefinitions>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="277*"/>
            <ColumnDefinition Width="118*"/>
            <ColumnDefinition Width="397*"/>
        </Grid.ColumnDefinitions>
        <TextBlock HorizontalAlignment="Left" Margin="0,10,0,0" TextWrapping="Wrap" VerticalAlignment="Top" Height="24" Width="1100" Grid.ColumnSpan="3"><Run FontWeight="Bold" Text="Embedded Software is divided into two classes * Systems Software (applications such as device drivers, operating systems and middleware)  * Applications Software( user level functionality)"/></TextBlock>
        <TextBlock HorizontalAlignment="Left" Margin="10,60,0,0" TextWrapping="Wrap" VerticalAlignment="Top" Width="582" Height="498" Grid.RowSpan="2" Grid.ColumnSpan="2"><Span><Run Text="Device drivers are the software libraries that initialize the hardware and manager access to the hardware by higher layers of software.  Device drivers are required for the processor architecture-specific functionality, memory and memory management drivers, bus initialization and transaction drivers and I/O (input/output) initialization and board level control drivers for storage devices and CPU level control drivers for debugging I/O: "/></Span><LineBreak/><LineBreak/><Span><Run Text="Architecture specific device driver examples are: "/></Span><LineBreak/><Run Text="• On chip memory &#xD;&#xA;•Integrated memory managers  (memory management units MMU&#xD;&#xA;•Floating point hardware"/><LineBreak/><Run/><LineBreak/><Span><Run Text="Generic device driver examples are: "/></Span><LineBreak/><Run Text="•Initialize and manage board buses such as I2c, PCI&#xD;&#xA;•Off chip memory ( level 2+ cache, controllers, flash)&#xD;&#xA;•Off chip I/O (Ethernet, RS-232, display, mouse, etc)"/><LineBreak/><Run/><LineBreak/><Span><Run Text="Device driver functionality includes: Hardware startup, initialization, shutdown, disable, enable, acquire, release, read, write, install, uninstall, mapping, un-mapping, software interrupt handling (interrupt handling startup, shutdown, disable, enable, servicing)."/></Span><LineBreak/><Run/><LineBreak/><Run FontWeight="Bold" Text="Interrupt Processing / device driver functionality"/><LineBreak/><Run Text="HW interrupts are initiated by an error event by the processor. Hence internal SW and HW interrupts are commonly referred to as exceptions. External interrupts are initiated by hardware besides the processor (board buses, I/O) and is wired via an input pin called the interrupt request level (IRQ) . These can be edge or level triggered.   Several different priority schemes can be implemented for interrupts. Examples of priority architectures include equal single level where the latest interrupt to get triggered gets processed by the processor, the static multi-level where priorities are assigned by a priority encoder where the interrupt with the higher priority gets processed by the processor first and the dynamic multilevel where a priority encoder assigns priorities and the priorities are reassigned when a new interrupt is triggered. "/><Run Text=" Upon receiving an interrupt an alternate set of instructions are performed. The performance of an embedded design is affected by the latencies involved with the interrupt handling scheme."/><LineBreak/><Run FontWeight="Bold"/><LineBreak/><Run/><LineBreak/><Run Text=""/></TextBlock>
        <Label Content="DEVICE DRIVERS" HorizontalAlignment="Left" Margin="289,34,0,0" VerticalAlignment="Top" Width="106"/>
        <Label Content="OPERATING SYSTEM" HorizontalAlignment="Left" Margin="0,34,0,0" VerticalAlignment="Top" Width="124" Grid.Column="2"/>
        <Label Content="MAIN FUNCTIONALITY OF OS (KERNEL)" Grid.Column="1" HorizontalAlignment="Left" Margin="200,63,0,0" Grid.Row="1" VerticalAlignment="Top" Width="219" RenderTransformOrigin="0.74,1.541" Grid.ColumnSpan="2">
            <Label.RenderTransform>
                <TransformGroup>
                    <ScaleTransform/>
                    <SkewTransform/>
                    <RotateTransform Angle="-0.075"/>
                    <TranslateTransform X="0.036" Y="-0.068"/>
                </TransformGroup>
            </Label.RenderTransform>
        </Label>
        <Image Margin="31,355,698,11" Source="Image21.png" Stretch="Fill" Grid.Column="1" Grid.ColumnSpan="2" Grid.Row="1" RenderTransformOrigin="0.5,0.5">
            <Image.RenderTransform>
                <TransformGroup>
                    <ScaleTransform/>
                    <SkewTransform AngleX="-0.19"/>
                    <RotateTransform/>
                    <TranslateTransform X="-0.497"/>
                </TransformGroup>
            </Image.RenderTransform>
        </Image>
        <TextBlock Grid.Column="2" HorizontalAlignment="Left" Margin="101,358,0,0" Grid.Row="1" TextWrapping="Wrap" VerticalAlignment="Top" Height="283" Width="247"><Run Text="DOS-C : Example of a unitasking embedded OS.  VxWorks(Wind River), embedded Linux (Timesys) and Jbed(Esmertec) are e.g of multi-tasking OSs. However one processor on an embedded board can execute one task or thread at any given time.  Hence through task implementation, scheduling, synchronization, and intertask communication mechanism that an OS provides the illusion of a single processor running multiple tasks simultaneously. In multitasking embedded OS, tasks are structured by inheritance or as a hierarchy of parent and child tasks.  All tasks create child tasks through the fork/exec or spawn system calls."/><LineBreak/><Run/><LineBreak/><LineBreak/><Run/><LineBreak/><Run Text=""/></TextBlock>
        <TextBlock Grid.Column="2" HorizontalAlignment="Left" Margin="353,10,0,0" TextWrapping="Wrap" VerticalAlignment="Top" Height="925" Width="430" Grid.RowSpan="2"><Run FontWeight="Bold" Text="Process Scheduling: "/><LineBreak/><Run Text="A scheduler is responsible for the order and duration of tasks to run on the CPU. "/><LineBreak/><Run Text="* Non-pre-emptive approach  "/><LineBreak/><Run Text="    * First come first served/ RuntoCompletion"/><LineBreak/><Run Text="    * Shortest Process Next/RunToCompletion"/><LineBreak/><Run Text="     *Co-operative"/><LineBreak/><Run Text="    * Examples include Round Robin/FIFO scheduling, priority(pre-emptive) scheduling, EDF/Clock driven scheduling."/><LineBreak/><Run Text="     * Round Robin Scheduling : each process is allocated an equal time slice. If a process finishes running before the end of the time slide, it releases the processor, if it does not finish it goes  to the end of the FIFO queue and completes executing the next time its turn comes around."/><LineBreak/><Run Text=" "/><LineBreak/><Run Text="Priority (Pre-Emptive) Scheduling: Every process is assigned a priority."/><LineBreak/><Run/><LineBreak/><Run FontWeight="Bold" Text="Inter task Communication and Synchronization"/><LineBreak/><Run Text="The embedded OS provides different mechanisms that allow for tasks in a multi tasking system to intercommunicate and synchronize their behavior. "/><LineBreak/><Run/><LineBreak/><Run FontWeight="Bold" Text="Memory Management"/><LineBreak/><Run Text="Since an OS must reside in the same memory space as the tasks it is managing, the protection mechanism needs to include managing its own code in memory and protecting it from the task code it is managing.  These functions amongst other consist of the memory mgmt components of an OS."/><LineBreak/><Run/><LineBreak/><Run FontWeight="Bold" Text="User Memory Space"/><LineBreak/><Run Text="Most OS processes run in one of two modes;  kernel mode and user mode depending on the routines that are being executed.  Kernel routines run in kernel mode  in a different memory space and level than higher layers of software such as middleware or applications. Higher layers of SW run in user mode and can access anything running in kernel mode only via system calls. "/><LineBreak/><Run/><LineBreak/><Run Text="Segmentation and paging simplifies the entire swapping of memory allocation and deallocation of tasks in memory.   "/><LineBreak/><Run/><LineBreak/><Run FontWeight="Bold" Text="Segmentation"/><LineBreak/><Run Text="The different types of information including source code, stack and data are divided into logical memory units of variable sizes called segments. A segment is  a set of logical addresses containing the same type of information. A text segment is a memory space containing the source code. A data segment is a memory space containing the source code's initialized variables. Data, text and BSS segments are all fixed in size at compile time and are static segments."/><LineBreak/><Run Text="Stack and heap segment is not fixed at compile time and change size at runtime and so are dynamic allocation components. A stack segment is a section of memory that is structured as a LIFO. A heap segment can be allocated in blocks at runtime and is set up as a free linked list of memory fragments. The memory mgm facilities offer memory allocation schemes ranging from first fit, next fit, best fit, worst fit and quick fit algorithms."/><LineBreak/><Run/><LineBreak/><Run FontWeight="Bold" Text="Virtual Memory:  "/><Run Text="Is typically implemented via demand segmentation and or demand paging memory fragmentation techniques. When virtual memory is implemented via these demand techniques, it means that only the pages and/or segments are loaded into RAM."/></TextBlock>
        <Image HorizontalAlignment="Left" Height="100" VerticalAlignment="Top" Width="100"/>
        <Image Grid.Column="1" HorizontalAlignment="Left" Height="258" Margin="64,100,0,0" Grid.Row="1" VerticalAlignment="Top" Width="483" Grid.ColumnSpan="2" Source="Image20.png"/>
        <Image Grid.ColumnSpan="2" Grid.Column="1" HorizontalAlignment="Left" Height="254" Margin="69,60,0,0" VerticalAlignment="Top" Width="478" Source="Image17.png" Grid.RowSpan="2"/>
        <Image HorizontalAlignment="Left" Height="98" Margin="38,351,0,0" Grid.Row="1" VerticalAlignment="Top" Width="505" Source="Image16.png"/>
        <Image HorizontalAlignment="Left" Height="215" Margin="10,480,0,-9" Grid.Row="1" VerticalAlignment="Top" Width="533" Source="Image15.png"/>
        <Label Content="Reference: Embedded Systems Architecture " HorizontalAlignment="Left" Margin="38,454,0,0" Grid.Row="1" VerticalAlignment="Top" Width="248"/>

    </Grid>
</Window>
